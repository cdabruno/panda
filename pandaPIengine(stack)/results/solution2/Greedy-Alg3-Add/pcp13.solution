Random seed: 42
Time limit: 20 seconds
Reading input from results/grounded/pcp13.sas.
- State has 6 bits divided into 6 mutex groups.
- Domain contains 8 actions.
- Domain contains 11 tasks.
- Domain contains 9 methods.
- The initial state contains 1 set bits.
- The initial task is "__top[]".
- State-based goal contains 1 bits.
- Instance is totally-ordered: no
- Instance has unique paths: yes
- Instance is parallel sequences: yes
Calculate SCCs...
- Number of SCCs: 11
- The problem is cyclic
- Number of cyclic SCCs: 2
- Number of cyclic SCCs of size 1: 2
Selected Planning Algorithm: progression searchParsing heuristics ...
Number of specified heuristics: 1
- the option "store cuts" of the RC heuristic can only be used with the inner heuristic LM-Cut. It will be disabled.
- Calculating minimal implied costs and distances (0 ms)
Heuristic #0 = hhRC2(add;distance;correct count)
Search config:
 - type: greedy
 - weight: 1
 - suboptimal: false
Visited List configured
- mode: parallel sequences order
- hashs to use: state task task-sequence
- memory information: topological ordering
- Visited list allows deletion of search nodes: true
Search Configuration
- Using JAIR 2020 progression algorithm
- Search is stopped after first solution is found.
- Utilizing heuristics.
- Greedy Search
- Starting state heuristic value: 11
Search Results
- Search time 0.067 seconds
- Visited list time 0.006107 seconds
- Visited list inserts 1788
- Visited list pruned 0
- Visited list contains 1788
- Visited list hash collisions 0
- Visited list used hash buckets 1788
- Generated 17709 search nodes
  Calculated heuristic for 7146 nodes
  One modifications 10563
  Effectless actions 0
- including 10563 one modification actions
- including 0 one modification methods
- and       0 progressions of effectless actions
- Generated 106656 nodes per second
- Final fringe contains 495 nodes
- Status: Solved
- Found solution of length 81
- Total costs of actions: 64
==>
32 t1G1[]
68 t1G2[]
117 t1G1[]
208 t1G2[]
300 t1G1[]
501 t1G2[]
681 t1G1[]
1098 t1G2[]
1119 t2G1[]
4548 t2G2[]
4556 t2G1[]
8512 t2G2[]
8520 t2G1[]
17645 t2G2[]
17653 t2G1[]
17654 t2G2[]
17655 p1G1[]
17656 p1G2[]
17657 p1G1[]
17658 p1G2[]
17659 p1G1[]
17660 p1G2[]
17661 p1G1[]
17662 p1G2[]
17663 p0G1[]
17664 p0G2[]
17665 p1G1[]
17666 p1G2[]
17667 p1G1[]
17668 p1G2[]
17669 p1G1[]
17670 p1G2[]
17671 p1G1[]
17672 p1G2[]
17673 p0G1[]
17674 p0G2[]
17675 p1G1[]
17676 p1G2[]
17677 p1G1[]
17678 p1G2[]
17679 p1G1[]
17680 p1G2[]
17681 p1G1[]
17682 p1G2[]
17683 p0G1[]
17684 p0G2[]
17685 p1G1[]
17686 p1G2[]
17687 p1G1[]
17688 p1G2[]
17689 p1G1[]
17690 p1G2[]
17691 p1G1[]
17692 p1G2[]
17693 p0G1[]
17694 p0G2[]
17695 p1G1[]
17696 p1G2[]
17697 p1G1[]
17698 p1G2[]
17699 p1G1[]
17700 p1G2[]
17701 p1G1[]
17702 p1G2[]
root 0
17652 SG2[] -> G2_S2t2_1_1_1_1_0 17654 17656 17658 17660 17662 17664
17644 SG1[] -> G1_S2t2_1 17653 17655
8519 SG2[] -> G2_S2t2_S_1_1_1_1_0 17645 17652 17666 17668 17670 17672 17674
8511 SG1[] -> G1_S2t2_S_1 8520 17644 17657
4555 SG2[] -> G2_S2t2_S_1_1_1_1_0 8512 8519 17676 17678 17680 17682 17684
4547 SG1[] -> G1_S2t2_S_1 4556 8511 17659
1118 SG2[] -> G2_S2t2_S_1_1_1_1_0 4548 4555 17686 17688 17690 17692 17694
1097 SG1[] -> G1_S2t2_S_1 1119 4547 17661
680 SG2[] -> G2_S2t1_S_1 1098 1118 17696
500 SG1[] -> G1_S2t1_S_0_1_1_1_1 681 1097 17663 17665 17667 17669 17671
299 SG2[] -> G2_S2t1_S_1 501 680 17698
207 SG1[] -> G1_S2t1_S_0_1_1_1_1 300 500 17673 17675 17677 17679 17681
116 SG2[] -> G2_S2t1_S_1 208 299 17700
67 SG1[] -> G1_S2t1_S_0_1_1_1_1 117 207 17683 17685 17687 17689 17691
31 SG1[] -> G1_S2t1_S_0_1_1_1_1 32 67 17693 17695 17697 17699 17701
3 SG2[] -> G2_S2t1_S_1 68 116 17702
0 __top[] -> __top_method 31 3
<==
